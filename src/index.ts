import { resolve } from 'path';
import type { VitePlugin, TrpcTypesPluginOptions } from './types';

export function trpcTypesPlugin(options: TrpcTypesPluginOptions = {}): VitePlugin {
  const {
    serverPath = '../server',
    routerFile = 'router',
    virtualModuleName = '@server/types',
    watch = true,
    watchFiles = [],
    logger = console.log,
    debug = false
  } = options;

  const serverRouterPathRelative = `../${serverPath}/${routerFile}`;

  const log = (message: string) => {
    if (debug) {
      logger(`[vite-plugin-trpc-types] ${message}`);
    }
  };

  return {
    name: 'vite-plugin-trpc-types',
    enforce: 'pre',

    config(config: any) {
      log('Configuring plugin...');
      
      // Add virtual module resolution
      return {
        resolve: {
          alias: {
            [virtualModuleName]: `\0virtual:${virtualModuleName}`,
            [`${virtualModuleName}.ts`]: `\0virtual:${virtualModuleName}`,
          },
        },
      };
    },

    resolveId(id: string) {
      // Handle virtual module for server types
      if (id === virtualModuleName || id === `${virtualModuleName}.ts`) {
        log(`Resolving virtual module: ${id}`);
        return `\0virtual:${virtualModuleName}`;
      }
      return null;
    },

    load(id: string) {
      if (id === `\0virtual:${virtualModuleName}`) {
        log('Loading virtual module content');
        
        return `
// Virtual module - auto-generated by vite-plugin-trpc-types
// This provides type-safe access to server types without build dependencies

// Import the router type without executing the implementation
import type { AppRouter } from '${serverRouterPathRelative}';

// Re-export the type
export type { AppRouter };

// This ensures the module is treated as type-only and prevents runtime execution
// The TypeScript language server should only see the type information
export {};
        `.trim();
      }
      return null;
    },

    configureServer(server: any) {
      if (!watch) {
        log('File watching disabled');
        return;
      }

      // Watch server files for changes
      const serverDir = resolve(serverPath);
      server.watcher.add(serverDir);

      // Add additional watch files
      watchFiles.forEach((file: string) => {
        const fullPath = resolve(serverPath, file);
        server.watcher.add(fullPath);
        log(`Added watch file: ${fullPath}`);
      });

      // Log when server files change
      server.watcher.on('change', (file: string) => {
        // Use the same precise file matching as HMR
        const normalizedFile = file.replace(/\\/g, '/');
        const normalizedServerDir = serverDir.replace(/\\/g, '/');
        
        if (normalizedFile.startsWith(normalizedServerDir) && 
            (file.endsWith('.ts') || file.endsWith('.js'))) {
          log(`Server file changed: ${file}`);
          logger('ðŸ”„ Server types changed, updating client types...');
          
          // Trigger a reload of the virtual module
          const module = server.moduleGraph.getModuleById(`\0virtual:${virtualModuleName}`);
          if (module) {
            server.moduleGraph.invalidateModule(module);
            log('Invalidated virtual module');
          }
        }
      });

      logger('ðŸŽ¯ tRPC types plugin active - watching server for changes');
      log(`Watching server directory: ${serverDir}`);
    },

    // Provide HMR support
    handleHotUpdate({ file, server }: { file: string; server: any }) {
      // Only handle HMR in development mode
      if (server.config.command !== 'serve') {
        return;
      }

      // More precise file matching - check if file is actually in the server directory
      const normalizedFile = file.replace(/\\/g, '/');
      const normalizedServerPath = resolve(serverPath).replace(/\\/g, '/');
      
      // Only handle files that are actually within our watched server directory
      if (normalizedFile.startsWith(normalizedServerPath) && 
          (file.endsWith('.ts') || file.endsWith('.js'))) {
        
        log(`HMR: Server file updated: ${file}`);
        logger('ðŸ”„ Server types updated, refreshing virtual module...');
        
        // Invalidate the virtual module to trigger re-compilation of dependent modules
        const module = server.moduleGraph.getModuleById(`\0virtual:${virtualModuleName}`);
        if (module) {
          server.moduleGraph.invalidateModule(module);
          log('HMR: Invalidated virtual module');
          
          // Trigger HMR for modules that import the virtual module
          server.ws.send({
            type: 'update',
            updates: [{
              type: 'js-update',
              path: `\0virtual:${virtualModuleName}`,
              acceptedPath: `\0virtual:${virtualModuleName}`,
              timestamp: Date.now(),
            }]
          });
        }
        
        // Return undefined to let Vite handle normal HMR for other files
        // Only return an empty array if we want to completely prevent HMR
        return;
      }
      
      // For all other files, let Vite handle HMR normally
      return;
    },
  };
}

// Re-export types for convenience
export type { TrpcTypesPluginOptions, VitePlugin } from './types';

// Export default for CommonJS compatibility
export default trpcTypesPlugin;
